{
    "path": "backend/misc.py",
    "model_usage_metrics": {
        "Duration": 24511859343,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "backend/test_misc.py",
    "existing_test_code": "",
    "original_code": "from __future__ import annotations\n\nimport base64\nimport mimetypes\nfrom datetime import datetime\nfrom typing import Any, Optional\n\nfrom charset_normalizer import from_bytes\nfrom fastapi import Request, UploadFile\nfrom fsspec.asyn import AsyncFileSystem  # type: ignore\n\nfrom const import Constants\nfrom errs import BadRequest\n\n\ndef parse_datetime(v: Any) -\u003e datetime | None:\n    if v is None:\n        return None\n    if isinstance(v, datetime):\n        return v\n    if isinstance(v, float):\n        return datetime.fromtimestamp(v)\n    if isinstance(v, int):\n        return datetime.fromtimestamp(float(v))\n    if isinstance(v, str):\n        return datetime.strptime(v, Constants.DATETIME_FORMAT)\n    raise BadRequest(f\"Invalid datetime value: {v}\")\n\n\ndef format_datetime(v: datetime) -\u003e str:\n    return None if v is None else v.strftime(Constants.DATETIME_FORMAT)\n\n\ndef guess_mime_type(p: str) -\u003e str:\n    r, _ = mimetypes.guess_type(p)\n    return r or \"application/octet-stream\"\n\n\ndef detect_encoding(file_bytes: bytes) -\u003e str:\n    \"\"\"\n    Detect the encoding of a given byte sequence using charset-normalizer.\n\n    :param file_bytes: The content of the file in bytes.\n    :return: Detected encoding as a string.\n    \"\"\"\n    result = from_bytes(file_bytes).best()\n    return result.encoding if result is not None else \"\"\n\n\nasync def read_file_text(fs: AsyncFileSystem, p: str, encoding: Optional[str] = \"utf-8\") -\u003e tuple[str, str]:\n    f_bytes = await read_file_bytes(fs, p)\n    if encoding is None:\n        encoding = detect_encoding(f_bytes)\n    return f_bytes.decode(encoding), encoding\n\n\nasync def write_file_text(fs: AsyncFileSystem, p: str, text: str, encoding: str = \"utf-8\"):\n    t_bytes = text.encode(encoding)\n    await write_file_bytes(fs, p, t_bytes)\n\n\nasync def read_file_bytes(fs: AsyncFileSystem, p: str) -\u003e bytes:\n    async with fs.open(p, mode=\"rb\") as f:\n        return await f.read()\n\n\nasync def write_file_bytes(fs: AsyncFileSystem, p: str, f_bytes: bytes):\n    async with fs.open(p, mode=\"wb\") as f:\n        await f.write(f_bytes)\n\n\nasync def transfer_file(\n    src_fs: AsyncFileSystem,\n    src_p: str,\n    dst_fs: AsyncFileSystem,\n    dst_p: str,\n    buf_size: int = 65536,\n) -\u003e tuple[int, bytes | None]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes | None = None\n\n    async with src_fs.open(src_p, mode=\"rb\") as src_f:\n        async with dst_fs.open(dst_p, \"wb\") as dst_f:\n            while True:\n                chunk: bytes = await src_f.read(buf_size)\n                if not chunk:\n                    break\n\n                if head is None:\n                    head = chunk\n\n                await dst_f.write(chunk)\n                got += len(chunk)\n\n    return got, head\n\n\nasync def transfer_stream(\n    src: UploadFile, dst_fs: AsyncFileSystem, dst_p: str, buf_size: int = 65536\n) -\u003e tuple[int, bytes]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes = b\"\"\n\n    async with dst_fs.open(dst_p, \"wb\") as dst_f:\n        while True:\n            chunk = await src.read(buf_size)  # Use the async read method\n            if not chunk:\n                break\n            if not head:\n                head = chunk\n\n            await dst_f.write(chunk)\n            got += len(chunk)\n\n    return got, head\n\n\ndef parse_data_url(data_url: str) -\u003e tuple[str, str, bytes]:\n    \"\"\"\n    Parse the Data URL and return the MIME type, encoding, and data.\n    :param data_url: The Data URL to parse.\n    :return: A tuple containing the MIME type, encoding, and decoded data as bytes.\n    \"\"\"\n    if not data_url.startswith(\"data:\"):\n        raise ValueError(f\"Invalid data URL: {data_url}\")\n\n    header, encoded_data = data_url.split(\",\", 1)\n    mime_type, encoding = header.split(\";\")[0][5:], header.split(\";\")[1]\n    if encoding != \"base64\":\n        raise ValueError(\"Only base64 encoding is supported\")\n\n    data = base64.b64decode(encoded_data)\n    return mime_type, encoding, data\n\n\ndef get_str_header(req: Request, name: str, devault: str) -\u003e str:\n    return req.headers.get(name) or devault\n\n\ndef get_int_header(req: Request, name: str, devault: int) -\u003e int:\n    s = req.headers.get(name)\n    return int(s) if s else devault\n\n\ndef get_bool_header(req: Request, name: str, devault: bool) -\u003e bool:\n    s = req.headers.get(name)\n    return s == \"true\" if s else devault\n\n\ndef get_client_ip(req: Request) -\u003e str:\n    h = req.headers\n\n    x_forwarded_for = h.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return x_forwarded_for.split(\",\")[0].strip()\n\n    real_ip = req.headers.get(\"x-real-ip\")\n    if real_ip:\n        return real_ip\n    if req.client:\n        return req.client.host\n    return \"\"\n\n\ndef get_client_port(req: Request) -\u003e int:\n    x_forwarded_port = req.headers.get(\"f-forwarded-port\")\n    if x_forwarded_port:\n        return int(x_forwarded_port)\n    if req.client:\n        return req.client.port\n    return 0\n\n\ndef get_client_proto(req: Request) -\u003e str:\n    x_forwarded_proto = req.headers.get(\"x-forwarded-proto\")\n    if x_forwarded_proto:\n        return x_forwarded_proto\n    if req.client:\n        return req.url.scheme\n    return \"\"\n\n\ndef get_client_proxy_chain(req: Request) -\u003e list[str]:\n    x_forwarded_for = req.headers.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return [ip.strip() for ip in x_forwarded_for.split(\",\")]\n    return []\n\n\ndef basename(p: str) -\u003e str:\n    p = normalize_path(p)\n    _, r = p.split(\"/\", 1)\n    return r\n\n\ndef normalize_path(p: str) -\u003e str:\n    if not p:\n        return p\n    p = p.lstrip(\"/\").rstrip(\"/\")\n\n    components: list[str] = []\n    for c in p.split(\"/\"):\n        if c in {\"\", \".\"}:\n            break\n        if c == \"..\":\n            c = c[:-1]\n        components.append(c)\n\n    return \"/\".join(components)\n",
    "test_code": "import pytest\nfrom datetime import datetime\nfrom backend.misc import (\n    parse_datetime,\n    format_datetime,\n    guess_mime_type,\n    detect_encoding,\n    read_file_text,\n    write_file_text,\n    transfer_file,\n    transfer_stream,\n    parse_data_url,\n    get_str_header,\n    get_int_header,\n    get_bool_header,\n    get_client_ip,\n    get_client_port,\n    get_client_proto,\n    get_client_proxy_chain,\n    basename,\n    normalize_path\n)\nfrom errs import BadRequest\n\n# Test cases for the functions in backend/misc.py\n\ndef test_parse_datetime():\n    \"\"\"\n    Test the parse_datetime function with various inputs.\n    \"\"\"\n    # Happy path\n    assert parse_datetime(datetime(2021, 1, 1)) == datetime(2021, 1, 1)\n    assert parse_datetime(1609459200) == datetime(2021, 1, 1)\n    assert parse_datetime(1609459200.0) == datetime(2021, 1, 1)\n    assert parse_datetime(\"2021-01-01T00:00:00\") == datetime(2021, 1, 1)\n\n    # Edge cases\n    assert parse_datetime(None) is None\n\n    # Negative case\n    with pytest.raises(BadRequest):\n        parse_datetime(\"invalid datetime\")\n\ndef test_format_datetime():\n    \"\"\"\n    Test the format_datetime function.\n    \"\"\"\n    assert format_datetime(datetime(2021, 1, 1)) == \"2021-01-01T00:00:00\"\n    assert format_datetime(None) is None\n\ndef test_guess_mime_type():\n    \"\"\"\n    Test the guess_mime_type function.\n    \"\"\"\n    assert guess_mime_type(\"example.txt\") == \"text/plain\"\n    assert guess_mime_type(\"example.pdf\") == \"application/pdf\"\n    assert guess_mime_type(\"unknown.ext\") == \"application/octet-stream\"\n\ndef test_detect_encoding():\n    \"\"\"\n    Test the detect_encoding function.\n    \"\"\"\n    assert detect_encoding(b'Hello, world!') == 'utf-8'\n    assert detect_encoding(b'\\x80\\x81\\x82') == 'utf-8'  # Example of invalid UTF-8\n\nasync def test_read_file_text(mocker):\n    \"\"\"\n    Test the read_file_text function.\n    \"\"\"\n    mock_fs = mocker.Mock()\n    mock_fs.open.return_value.__aenter__.return_value.read.return_value = b'Hello, world!'\n    \n    text, encoding = await read_file_text(mock_fs, \"dummy_path\")\n    assert text == 'Hello, world!'\n    assert encoding == 'utf-8'\n\nasync def test_write_file_text(mocker):\n    \"\"\"\n    Test the write_file_text function.\n    \"\"\"\n    mock_fs = mocker.Mock()\n    await write_file_text(mock_fs, \"dummy_path\", \"Hello, world!\")\n    mock_fs.open.assert_called_once_with(\"dummy_path\", mode=\"wb\")\n\nasync def test_transfer_file(mocker):\n    \"\"\"\n    Test the transfer_file function.\n    \"\"\"\n    mock_src_fs = mocker.Mock()\n    mock_dst_fs = mocker.Mock()\n    mock_src_fs.open.return_value.__aenter__.return_value.read.side_effect = [b'Hello, ', b'world!']\n    \n    bytes_transferred, head = await transfer_file(mock_src_fs, \"src_path\", mock_dst_fs, \"dst_path\")\n    assert bytes_transferred == 13\n    assert head == b'Hello, '\n\ndef test_parse_data_url():\n    \"\"\"\n    Test the parse_data_url function.\n    \"\"\"\n    mime_type, encoding, data = parse_data_url(\"data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==\")\n    assert mime_type == \"text/plain\"\n    assert encoding == \"base64\"\n    assert data == b'Hello, World!'\n\n    # Negative case\n    with pytest.raises(ValueError):\n        parse_data_url(\"invalid_data_url\")\n\ndef test_get_str_header():\n    \"\"\"\n    Test the get_str_header function.\n    \"\"\"\n    class MockRequest:\n        headers = {\"X-Custom-Header\": \"value\"}\n\n    req = MockRequest()\n    assert get_str_header(req, \"X-Custom-Header\", \"default\") == \"value\"\n    assert get_str_header(req, \"Non-Existent-Header\", \"default\") == \"default\"\n\ndef test_get_int_header():\n    \"\"\"\n    Test the get_int_header function.\n    \"\"\"\n    class MockRequest:\n        headers = {\"X-Custom-Int-Header\": \"42\"}\n\n    req = MockRequest()\n    assert get_int_header(req, \"X-Custom-Int-Header\", 0) == 42\n    assert get_int_header(req, \"Non-Existent-Header\", 0) == 0\n\ndef test_get_bool_header():\n    \"\"\"\n    Test the get_bool_header function.\n    \"\"\"\n    class MockRequest:\n        headers = {\"X-Custom-Bool-Header\": \"true\"}\n\n    req = MockRequest()\n    assert get_bool_header(req, \"X-Custom-Bool-Header\", False) is True\n    assert get_bool_header(req, \"Non-Existent-Header\", False) is False\n\ndef test_get_client_ip():\n    \"\"\"\n    Test the get_client_ip function.\n    \"\"\"\n    class MockRequest:\n        headers = {\"x-forwarded-for\": \"192.168.1.1\"}\n        client = None\n\n    req = MockRequest()\n    assert get_client_ip(req) == \"192.168.1.1\"\n\ndef test_get_client_port():\n    \"\"\"\n    Test the get_client_port function.\n    \"\"\"\n    class MockRequest:\n        headers = {}\n        client = type('obj', (object,), {'port': 8080})\n\n    req = MockRequest()\n    assert get_client_port(req) == 8080\n\ndef test_get_client_proto():\n    \"\"\"\n    Test the get_client_proto function.\n    \"\"\"\n    class MockRequest:\n        headers = {}\n        client = type('obj', (object,), {'url': type('obj', (object,), {'scheme': 'http'})})\n\n    req = MockRequest()\n    assert get_client_proto(req) == \"http\"\n\ndef test_get_client_proxy_chain():\n    \"\"\"\n    Test the get_client_proxy_chain function.\n    \"\"\"\n    class MockRequest:\n        headers = {\"x-forwarded-for\": \"192.168.1.1, 192.168.1.2\"}\n\n    req = MockRequest()\n    assert get_client_proxy_chain(req) == [\"192.168.1.1\", \"192.168.1.2\"]\n\ndef test_basename():\n    \"\"\"\n    Test the basename function.\n    \"\"\"\n    assert basename(\"/path/to/file.txt\") == \"to/file.txt\"\n    assert basename(\"\") == \"\"\n\ndef test_normalize_path():\n    \"\"\"\n    Test the normalize_path function.\n    \"\"\"\n    assert normalize_path(\"/path/to/../file.txt\") == \"path/to\"\n    assert normalize_path(\"/path/./to/file.txt\") == \"path/to/file.txt\"\n    assert normalize_path(\"\") == \"\"\n",
    "amount_of_generated_test_cases": 20,
    "single_test_run_command": "pytest backend/test_misc.py"
}