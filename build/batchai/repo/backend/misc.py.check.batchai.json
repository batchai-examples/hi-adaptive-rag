{
    "has_issue": true,
    "overall_severity": "minor",
    "issues": [
        {
            "short_description": "Incorrect header key in get_client_port function",
            "detailed_explaination": "The header key 'f-forwarded-port' is likely a typo. The correct header key should be 'x-forwarded-port'.",
            "suggestion": "Change 'f-forwarded-port' to 'x-forwarded-port' in the get_client_port function.",
            "issue_line_begin": 138,
            "issue_line_end": 140,
            "issue_reference_urls": [
                "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Port"
            ],
            "severity": "minor",
            "severity_reason": "This could lead to incorrect behavior when trying to retrieve the client's port."
        }
    ],
    "fixed_code": "from __future__ import annotations\n\nimport base64\nimport mimetypes\nfrom datetime import datetime\nfrom typing import Any, Optional\n\nfrom charset_normalizer import from_bytes\nfrom fastapi import Request, UploadFile\nfrom fsspec.asyn import AsyncFileSystem  # type: ignore\n\nfrom const import Constants\nfrom errs import BadRequest\n\n\ndef parse_datetime(v: Any) -\u003e datetime | None:\n    if v is None:\n        return None\n    if isinstance(v, datetime):\n        return v\n    if isinstance(v, float):\n        return datetime.fromtimestamp(v)\n    if isinstance(v, int):\n        return datetime.fromtimestamp(float(v))\n    if isinstance(v, str):\n        return datetime.strptime(v, Constants.DATETIME_FORMAT)\n    raise BadRequest(f\"Invalid datetime value: {v}\")\n\n\ndef format_datetime(v: datetime) -\u003e str:\n    return None if v is None else v.strftime(Constants.DATETIME_FORMAT)\n\n\ndef guess_mime_type(p: str) -\u003e str:\n    r, _ = mimetypes.guess_type(p)\n    return r or \"application/octet-stream\"\n\n\ndef detect_encoding(file_bytes: bytes) -\u003e str:\n    \"\"\"\n    Detect the encoding of a given byte sequence using charset-normalizer.\n\n    :param file_bytes: The content of the file in bytes.\n    :return: Detected encoding as a string.\n    \"\"\"\n    result = from_bytes(file_bytes).best()\n    return result.encoding if result is not None else \"\"\n\n\nasync def read_file_text(fs: AsyncFileSystem, p: str, encoding: Optional[str] = \"utf-8\") -\u003e tuple[str, str]:\n    f_bytes = await read_file_bytes(fs, p)\n    if encoding is None:\n        encoding = detect_encoding(f_bytes)\n    return f_bytes.decode(encoding), encoding\n\n\nasync def write_file_text(fs: AsyncFileSystem, p: str, text: str, encoding: str = \"utf-8\"):\n    t_bytes = text.encode(encoding)\n    await write_file_bytes(fs, p, t_bytes)\n\n\nasync def read_file_bytes(fs: AsyncFileSystem, p: str) -\u003e bytes:\n    async with fs.open(p, mode=\"rb\") as f:\n        return await f.read()\n\n\nasync def write_file_bytes(fs: AsyncFileSystem, p: str, f_bytes: bytes):\n    async with fs.open(p, mode=\"wb\") as f:\n        await f.write(f_bytes)\n\n\nasync def transfer_file(\n    src_fs: AsyncFileSystem,\n    src_p: str,\n    dst_fs: AsyncFileSystem,\n    dst_p: str,\n    buf_size: int = 65536,\n) -\u003e tuple[int, bytes | None]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes | None = None\n\n    async with src_fs.open(src_p, mode=\"rb\") as src_f:\n        async with dst_fs.open(dst_p, \"wb\") as dst_f:\n            while True:\n                chunk: bytes = await src_f.read(buf_size)\n                if not chunk:\n                    break\n\n                if head is None:\n                    head = chunk\n\n                await dst_f.write(chunk)\n                got += len(chunk)\n\n    return got, head\n\n\nasync def transfer_stream(\n    src: UploadFile, dst_fs: AsyncFileSystem, dst_p: str, buf_size: int = 65536\n) -\u003e tuple[int, bytes]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes = b\"\"\n\n    async with dst_fs.open(dst_p, \"wb\") as dst_f:\n        while True:\n            chunk = await src.read(buf_size)  # Use the async read method\n            if not chunk:\n                break\n            if not head:\n                head = chunk\n\n            await dst_f.write(chunk)\n            got += len(chunk)\n\n    return got, head\n\n\ndef parse_data_url(data_url: str) -\u003e tuple[str, str, bytes]:\n    \"\"\"\n    Parse the Data URL and return the MIME type, encoding, and data.\n    :param data_url: The Data URL to parse.\n    :return: A tuple containing the MIME type, encoding, and decoded data as bytes.\n    \"\"\"\n    if not data_url.startswith(\"data:\"):\n        raise ValueError(f\"Invalid data URL: {data_url}\")\n\n    header, encoded_data = data_url.split(\",\", 1)\n    mime_type, encoding = header.split(\";\")[0][5:], header.split(\";\")[1]\n    if encoding != \"base64\":\n        raise ValueError(\"Only base64 encoding is supported\")\n\n    data = base64.b64decode(encoded_data)\n    return mime_type, encoding, data\n\n\ndef get_str_header(req: Request, name: str, devault: str) -\u003e str:\n    return req.headers.get(name) or devault\n\n\ndef get_int_header(req: Request, name: str, devault: int) -\u003e int:\n    s = req.headers.get(name)\n    return int(s) if s else devault\n\n\ndef get_bool_header(req: Request, name: str, devault: bool) -\u003e bool:\n    s = req.headers.get(name)\n    return s == \"true\" if s else devault\n\n\ndef get_client_ip(req: Request) -\u003e str:\n    h = req.headers\n\n    x_forwarded_for = h.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return x_forwarded_for.split(\",\")[0].strip()\n\n    real_ip = req.headers.get(\"x-real-ip\")\n    if real_ip:\n        return real_ip\n    if req.client:\n        return req.client.host\n    return \"\"\n\n\ndef get_client_port(req: Request) -\u003e int:\n    x_forwarded_port = req.headers.get(\"x-forwarded-port\")  # Fixed header key\n    if x_forwarded_port:\n        return int(x_forwarded_port)\n    if req.client:\n        return req.client.port\n    return 0\n\n\ndef get_client_proto(req: Request) -\u003e str:\n    x_forwarded_proto = req.headers.get(\"x-forwarded-proto\")\n    if x_forwarded_proto:\n        return x_forwarded_proto\n    if req.client:\n        return req.url.scheme\n    return \"\"\n\n\ndef get_client_proxy_chain(req: Request) -\u003e list[str]:\n    x_forwarded_for = req.headers.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return [ip.strip() for ip in x_forwarded_for.split(\",\")]\n    return []\n\n\ndef basename(p: str) -\u003e str:\n    p = normalize_path(p)\n    _, r = p.split(\"/\", 1)\n    return r\n\n\ndef normalize_path(p: str) -\u003e str:\n    if not p:\n        return p\n    p = p.lstrip(\"/\").rstrip(\"/\")\n\n    components: list[str] = []\n    for c in p.split(\"/\"):\n        if c in {\"\", \".\"}:\n            break\n        if c == \"..\":\n            c = c[:-1]\n        components.append(c)\n\n    return \"/\".join(components)\n",
    "original_code": "from __future__ import annotations\n\nimport base64\nimport mimetypes\nfrom datetime import datetime\nfrom typing import Any, Optional\n\nfrom charset_normalizer import from_bytes\nfrom fastapi import Request, UploadFile\nfrom fsspec.asyn import AsyncFileSystem  # type: ignore\n\nfrom const import Constants\nfrom errs import BadRequest\n\n\ndef parse_datetime(v: Any) -\u003e datetime | None:\n    if v is None:\n        return None\n    if isinstance(v, datetime):\n        return v\n    if isinstance(v, float):\n        return datetime.fromtimestamp(v)\n    if isinstance(v, int):\n        return datetime.fromtimestamp(float(v))\n    if isinstance(v, str):\n        return datetime.strptime(v, Constants.DATETIME_FORMAT)\n    raise BadRequest(f\"Invalid datetime value: {v}\")\n\n\ndef format_datetime(v: datetime) -\u003e str:\n    return None if v is None else v.strftime(Constants.DATETIME_FORMAT)\n\n\ndef guess_mime_type(p: str) -\u003e str:\n    r, _ = mimetypes.guess_type(p)\n    return r or \"application/octet-stream\"\n\n\ndef detect_encoding(file_bytes: bytes) -\u003e str:\n    \"\"\"\n    Detect the encoding of a given byte sequence using charset-normalizer.\n\n    :param file_bytes: The content of the file in bytes.\n    :return: Detected encoding as a string.\n    \"\"\"\n    result = from_bytes(file_bytes).best()\n    return result.encoding if result is not None else \"\"\n\n\nasync def read_file_text(fs: AsyncFileSystem, p: str, encoding: Optional[str] = \"utf-8\") -\u003e tuple[str, str]:\n    f_bytes = await read_file_bytes(fs, p)\n    if encoding is None:\n        encoding = detect_encoding(f_bytes)\n    return f_bytes.decode(encoding), encoding\n\n\nasync def write_file_text(fs: AsyncFileSystem, p: str, text: str, encoding: str = \"utf-8\"):\n    t_bytes = text.encode(encoding)\n    await write_file_bytes(fs, p, t_bytes)\n\n\nasync def read_file_bytes(fs: AsyncFileSystem, p: str) -\u003e bytes:\n    async with fs.open(p, mode=\"rb\") as f:\n        return await f.read()\n\n\nasync def write_file_bytes(fs: AsyncFileSystem, p: str, f_bytes: bytes):\n    async with fs.open(p, mode=\"wb\") as f:\n        await f.write(f_bytes)\n\n\nasync def transfer_file(\n    src_fs: AsyncFileSystem,\n    src_p: str,\n    dst_fs: AsyncFileSystem,\n    dst_p: str,\n    buf_size: int = 65536,\n) -\u003e tuple[int, bytes | None]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes | None = None\n\n    async with src_fs.open(src_p, mode=\"rb\") as src_f:\n        async with dst_fs.open(dst_p, \"wb\") as dst_f:\n            while True:\n                chunk: bytes = await src_f.read(buf_size)\n                if not chunk:\n                    break\n\n                if head is None:\n                    head = chunk\n\n                await dst_f.write(chunk)\n                got += len(chunk)\n\n    return got, head\n\n\nasync def transfer_stream(\n    src: UploadFile, dst_fs: AsyncFileSystem, dst_p: str, buf_size: int = 65536\n) -\u003e tuple[int, bytes]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes = b\"\"\n\n    async with dst_fs.open(dst_p, \"wb\") as dst_f:\n        while True:\n            chunk = await src.read(buf_size)  # Use the async read method\n            if not chunk:\n                break\n            if not head:\n                head = chunk\n\n            await dst_f.write(chunk)\n            got += len(chunk)\n\n    return got, head\n\n\ndef parse_data_url(data_url: str) -\u003e tuple[str, str, bytes]:\n    \"\"\"\n    Parse the Data URL and return the MIME type, encoding, and data.\n    :param data_url: The Data URL to parse.\n    :return: A tuple containing the MIME type, encoding, and decoded data as bytes.\n    \"\"\"\n    if not data_url.startswith(\"data:\"):\n        raise ValueError(f\"Invalid data URL: {data_url}\")\n\n    header, encoded_data = data_url.split(\",\", 1)\n    mime_type, encoding = header.split(\";\")[0][5:], header.split(\";\")[1]\n    if encoding != \"base64\":\n        raise ValueError(\"Only base64 encoding is supported\")\n\n    data = base64.b64decode(encoded_data)\n    return mime_type, encoding, data\n\n\ndef get_str_header(req: Request, name: str, devault: str) -\u003e str:\n    return req.headers.get(name) or devault\n\n\ndef get_int_header(req: Request, name: str, devault: int) -\u003e int:\n    s = req.headers.get(name)\n    return int(s) if s else devault\n\n\ndef get_bool_header(req: Request, name: str, devault: bool) -\u003e bool:\n    s = req.headers.get(name)\n    return s == \"true\" if s else devault\n\n\ndef get_client_ip(req: Request) -\u003e str:\n    h = req.headers\n\n    x_forwarded_for = h.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return x_forwarded_for.split(\",\")[0].strip()\n\n    real_ip = req.headers.get(\"x-real-ip\")\n    if real_ip:\n        return real_ip\n    if req.client:\n        return req.client.host\n    return \"\"\n\n\ndef get_client_port(req: Request) -\u003e int:\n    x_forwarded_port = req.headers.get(\"f-forwarded-port\")\n    if x_forwarded_port:\n        return int(x_forwarded_port)\n    if req.client:\n        return req.client.port\n    return 0\n\n\ndef get_client_proto(req: Request) -\u003e str:\n    x_forwarded_proto = req.headers.get(\"x-forwarded-proto\")\n    if x_forwarded_proto:\n        return x_forwarded_proto\n    if req.client:\n        return req.url.scheme\n    return \"\"\n\n\ndef get_client_proxy_chain(req: Request) -\u003e list[str]:\n    x_forwarded_for = req.headers.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return [ip.strip() for ip in x_forwarded_for.split(\",\")]\n    return []\n\n\ndef basename(p: str) -\u003e str:\n    p = normalize_path(p)\n    _, r = p.split(\"/\", 1)\n    return r\n\n\ndef normalize_path(p: str) -\u003e str:\n    if not p:\n        return p\n    p = p.lstrip(\"/\").rstrip(\"/\")\n\n    components: list[str] = []\n    for c in p.split(\"/\"):\n        if c in {\"\", \".\"}:\n            break\n        if c == \"..\":\n            c = c[:-1]\n        components.append(c)\n\n    return \"/\".join(components)\n",
    "path": "backend/misc.py",
    "model_usage_metrics": {
        "Duration": 21575536991,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    }
}